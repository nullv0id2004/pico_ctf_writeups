# MiniRSA
## Description
What happens if you have a small exponent? There is a twist though, we padded the plaintext so that (M ** e) is just barely larger than N. Let's decrypt this: [ciphertext](/Cryptography/miniRSA/miniRSA_resources/ciphertext)

## Type: Cryptography
## Solving
1) I read about RSA crytptography through [here](https://crypto.stackexchange.com/questions/6770/cracking-an-rsa-with-no-padding-and-very-small-e/6771#6771)
2) Without padding, encryption of `m` is `m^e mod n`: the message m is interpreted as an integer, then raised to exponent `e`, and the result is reduced modulo `n`. If `e = 3` and `m` is short, then `m^3` could be an integer which is smaller than n, in which case the modulo operation is a no-operation. In that case, we can just compute the cube root of the value we have. However, we cannot simply compute `c^(1/3)` (where `c` is the ciphertext) because there is a slight amount of padding to the message to make `m^e` larger than `n`, which makes the modulo operation take effect.
3) With a short `m` slightly wider than `n^(1/e)`, which is what we have, we are given `c = m^e mod n` and can find by enumeration `k` such that k * n + c is an eth power: then `m = (k * n + c)^(1/e)`.
I got this equation by remainder therorem.
4) I used python [flag.py](/Cryptography/miniRSA/miniRSA_resources/flag.py) to find `m = k * n + c` for consecutive values of k where k is an integer and converted that to hex. Now I checked that if `7069636f` is present in m, here i am checking if pico is present in m and if yes then i am converting it to `ASCII` and printing that string.

```py
import binascii
def find_invpow(x,n):
    """Finds the integer component of the n'th root of x,
    an integer such that y ** n <= x < (y + 1) ** n.
    """
    high = 1
    while high ** n <= x:
        high *= 2
    low = high//2
    while low < high:
        mid = (low + high) // 2
        if low < mid and mid**n < x:
            low = mid
        elif high > mid and mid**n > x:
            high = mid
        else:
            return mid
    return mid + 1

c= 1220012318588871886132524757898884422174534558055593713309088304910273991073554732659977133980685370899257850121970812405700793710546674062154237544840177616746805668666317481140872605653768484867292138139949076102907399831998827567645230986345455915692863094364797526497302082734955903755050638155202890599808146956044568639690002921620304969196755223769438221859424275683828638207433071955615349052424040706261639770492033970498727183446507482899334169592311953247661557664109356372049286283480939368007035616954029177541731719684026988849403756133033533171081378815289443019437298879607294287249591634702823432448559878065453908423094452047188125358790554039587941488937855941604809869090304206028751113018999782990033393577325766685647733181521675994939066814158759362046052998582186178682593597175186539419118605277037256659707217066953121398700583644564201414551200278389319378027058801216150663695102005048597466358061508725332471930736629781191567057009302022382219283560795941554288119544255055962
e= 3
k= 1
n= 1615765684321463054078226051959887884233678317734892901740763321135213636796075462401950274602405095138589898087428337758445013281488966866073355710771864671726991918706558071231266976427184673800225254531695928541272546385146495736420261815693810544589811104967829354461491178200126099661909654163542661541699404839644035177445092988952614918424317082380174383819025585076206641993479326576180793544321194357018916215113009742654408597083724508169216182008449693917227497813165444372201517541788989925461711067825681947947471001390843774746442699739386923285801022685451221261010798837646928092277556198145662924691803032880040492762442561497760689933601781401617086600593482127465655390841361154025890679757514060456103104199255917164678161972735858939464790960448345988941481499050248673128656508055285037090026439683847266536283160142071643015434813473463469733112182328678706702116054036618277506997666534567846763938692335069955755244438415377933440029498378955355877502743215305768814857864433151287
while True:
    flag =("{:x}".format(find_invpow((k*n+c),3)))
    if "7069636f" in flag: #searching if "pico" is in flag
        print(flag)
        print(binascii.unhexlify(flag))
        break;
    else:
        k=k+1
        print(k)

```
5) I ran it in terminal

        python3 flag.py
        
![](/Cryptography/miniRSA/miniRSA_resources/mr1.png)

        Flag: picoCTF{e_sh0u1d_b3_lArg3r_6e2e6bda}
