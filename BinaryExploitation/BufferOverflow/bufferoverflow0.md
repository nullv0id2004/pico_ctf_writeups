# Buffer OverFlow
## Description
Smash the stack Let's start off simple, can you overflow the correct buffer? The program is available [here](https://artifacts.picoctf.net/c/173/vuln). You can view source [here](https://artifacts.picoctf.net/c/173/vuln.c). And connect with it using: `nc saturn.picoctf.net 55984`
## Type: Binary Exploitation
## Solving:
1) I inspected the c file
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>

#define FLAGSIZE_MAX 64

char flag[FLAGSIZE_MAX];

void sigsegv_handler(int sig) {
  printf("%s\n", flag);
  fflush(stdout);
  exit(1);
}

void vuln(char *input){
  char buf2[16];
  strcpy(buf2, input);
}

int main(int argc, char **argv){
  
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("%s %s", "Please create 'flag.txt' in this directory with your",
                    "own debugging flag.\n");
    exit(0);
  }
  
  fgets(flag,FLAGSIZE_MAX,f);
  signal(SIGSEGV, sigsegv_handler); // Set up signal handler
  
  gid_t gid = getegid();
  setresgid(gid, gid, gid);


  printf("Input: ");
  fflush(stdout);
  char buf1[100];
  gets(buf1); 
  vuln(buf1);
  printf("The program will exit now\n");
  return 0;
}

```
2) The program uses `gets` function which is never to be used cause its a very dangerous function. `gets()`reads a line from stdin into the buffer pointed to by s
until either a terminating newline or EOF, which it replaces with a null byte `('\0')`.  No check for buffer overrun is performed.
3) Never use `gets()`.  Because it is impossible to tell without knowing the data in advance how many characters gets() will read, and because `gets()` will continue to store characters past the end of the buffer, it is extremely dangerous to use.  It has been used to break computer security.
4) So here we will do the same and overflow the gets function to get the flag. Even `strcpy` is dangerous because the other char array should also have enough space to accomodate whats to be copied.
5) i ran the program using

        nc saturn.picoctf.net 55984

6) I overflowed the input by repeatedly entering a about 20 times and got the flag.

        Flag: picoCTF{ov3rfl0ws_ar3nt_that_bad_ef01832d}

